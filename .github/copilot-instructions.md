# GitHub Copilot instructions for dlm-js  

Purpose
- Help coding agents become productive immediately: what the project *is*, how it's built/tested, important conventions, and where to look for authoritative behavior.

High-level summary (big picture) üîé
- dlm-js is a computation-only TypeScript port of a MATLAB Dynamic Linear Model (DLM) using the `@hamk-uas/jax-js-nonconsuming` numeric backend. The library implements Kalman filter + RTS smoother and exposes CPU/WASM/WebGPU-capable implementations via `dlmFit`/`dlmSmo` (modes: `for`, `scan`, `jit`). `dlmForecast` propagates the last smoothed state h steps ahead with no new observations, returning `yhat`, `ystd` (monotonically growing), full state/covariance trajectories, and optional covariate support. `dlmGenSys` generates G/F state-space matrices for polynomial trend, seasonal, and AR components. `dlmMLE` estimates observation noise, state noise, and optionally AR coefficients via autodiff (`jit(valueAndGrad + optax Adam)`, `fitar: true` for AR coefficient estimation).
- The authoritative numerical reference is generated by Octave (`tests/octave/niledemo.m`, `tests/octave/gensys_tests.m`, `tests/octave/missingdata_test.m`) and compared in `tests/niledemo.test.ts`, `tests/gensys.test.ts`, and `tests/missing.test.ts`. Synthetic ground-truth tests in `tests/synthetic.test.ts` verify against mathematically known true states.

Quick start ‚Äî commands you will need (copy/paste) ‚ñ∂Ô∏è
- Install: `pnpm install`.
- Run node tests (uses source TS): `pnpm vitest run` or `pnpm run test:node`.
- Lint (jax-js-nonconsuming memory rules): `pnpm run lint`.
- Generate API docs: `pnpm run docs` (outputs to `docs/`, opens at `docs/index.html`).
- Generate Octave reference (requires `octave-cli`): `pnpm run test:octave` (produces `tests/*-out-m.json`).
- Generate SVG plots: `pnpm run gen:svg` (produces `assets/*.svg`; also writes timing sidecars to `assets/timings/*.json` and auto-patches `<!-- timing:KEY -->` markers in all .md files).
- Update stale timing values in .md files: `pnpm run update:timings` (reads existing sidecars; no re-run). Inspect slots with `pnpm run update:timings:list`. Preview changes without writing with `pnpm run update:timings:dry`.
- Benchmark all MLE comparison-table rows (Nile order=0, Kaisaniemi): `pnpm run bench:mle` (writes `assets/timings/collect-mle-benchmark.json` and auto-patches .md).
- Benchmark `checkpoint` strategies: `pnpm run bench:checkpoint` (writes `assets/timings/bench-checkpoint.json` and auto-patches .md).
- Build for distribution: `pnpm run build`.
- Full CI-local check: `pnpm run test` (runs lint + Octave reference + Node tests).

Files & places to inspect first üìÅ
- Implementation: `src/index.ts` (Kalman filter + RTS smoother, `dlmForecast` h-step-ahead forecast, modes, memory/dispose patterns, API signatures).
- MLE parameter estimation: `src/mle.ts` (`dlmMLE`: autodiff-based MLE via `jit(valueAndGrad + optax Adam)`, AD-safe `buildDiagW`, `buildG` for AR coefficient estimation, `makeKalmanLoss` using `lax.scan`). Supports `fitar: true` for AR coefficient estimation.
- State space generator: `src/dlmgensys.ts` (polynomial, seasonal, AR component assembly, `findArInds` for AR state indexing).
- Types & helpers: `src/types.ts` (TypedArray usage, `getFloatArrayType`, `DlmForecastResult` interface).
- Test matrix: `tests/test-matrix.ts` (shared device √ó dtype configs and tolerances).
- Tests: `tests/niledemo.test.ts` (Nile demo vs Octave), `tests/gensys.test.ts` (multi-model vs Octave), `tests/synthetic.test.ts` (known true states, statistical assertions), `tests/mle.test.ts` (MLE parameter & AR coefficient estimation on WASM), `tests/covariate.test.ts` (X parameter / Œ≤ recovery), `tests/ozone.test.ts` (ozone demo smoke tests), `tests/forecast.test.ts` (h-step-ahead forecasting: monotone ystd, finite outputs, covariate support, all models), `tests/missing.test.ts` (order=1 and order=0 with NaN observations vs Octave reference).
- Reference generators: `tests/octave/niledemo.m`, `tests/octave/gensys_tests.m`, `tests/octave/kaisaniemi_demo.m`, `tests/octave/missingdata_test.m` (MATLAB/Octave ground truth).
- SVG generators: `scripts/gen-niledemo-svg.ts`, `scripts/gen-kaisaniemi-svg.ts`, `scripts/gen-trigar-svg.ts`, `scripts/gen-nile-mle-anim-svg.ts` (+ `scripts/collect-nile-mle-frames.ts`), `scripts/gen-energy-mle-anim-svg.ts` (+ `scripts/collect-energy-mle-frames.ts`), `scripts/gen-ozone-svg.ts`, `scripts/gen-missing-svg.ts` (missing-data demo with NaN interpolation and ystd widening).
- MLE comparison: `mle-comparison.md` (dlm-js MLE vs MATLAB DLM parameter estimation, with benchmark timings).
- Upstream issues: `issues/` (precision analysis filed to jax-js-nonconsuming).
- Build / CI hooks: `package.json`, `vite.config.ts`.

Project-specific conventions & gotchas ‚ö†Ô∏è
- Execution modes: `for` (fastest in interpreter), `scan` (enables JIT/AD), `jit` (jit(scan) ‚Äî fastest after compilation). Tests exercise all three ‚Äî any numeric change must pass all modes.
- Device/dtype behavior: tests pick backend automatically; `webgpu` ‚Üí float32 (more numeric drift), `wasm`/`cpu` ‚Üí float64 preferred for bit-for-bit checks. When debugging flakiness, force CPU + Float64.
- Reference-first testing: Octave output is the source of truth. If you change numerics intentionally, regenerate Octave output and update tests with justification.
- Partial-output testing: use `tests/niledemo-keys.json` to limit comparisons for partial implementations.
- Memory management: This project uses `@hamk-uas/jax-js-nonconsuming` which has **non-consuming ops** ‚Äî operations leave inputs intact. Use TC39 `using` keyword for automatic disposal and `tree.dispose()` for bulk cleanup. Do NOT use `.ref` (that is the consuming-ops pattern from a different fork).
- **Timing and computed markers in .md files**: Every machine-dependent value in README.md or mle-comparison.md uses one of two invisible HTML marker forms:
  - `<!-- timing:KEY -->VALUE<!-- /timing -->` ‚Äî replaced with `formatTiming(sidecar[field])` for the named KEY. Registry: `scripts/lib/timing-registry.ts`. Sidecars: `assets/timings/<script-basename>.json`.
  - `<!-- computed:EXPR -->VALUE<!-- /computed -->` ‚Äî EXPR is a JS expression using `slot("KEY")` (raw numeric value from a sidecar) and `static("KEY")` (value from `assets/timings/static-references.json`). Used for derived verbal claims, e.g. `static("octave-nile-order1-elapsed-ms") < slot("nile-mle:elapsed") ? "faster" : "slower"` or `Math.abs(slot("mle-bench:nile-order1:lik") - static("octave-nile-order1-lik")).toFixed(1)`.
  - `assets/timings/static-references.json` holds **manually-measured Octave** fminsearch timings and ‚àí2logL values. The `machine` field is auto-updated by `stampMachineInfo()` (called by `bench:mle` and `bench:checkpoint`). Update the Octave timing fields and `_measured` date manually whenever Octave is re-run on a different machine.
  - Both marker types are patched by a single `pnpm run update:timings` call after any sidecar or static-references change.
  - **Full mle-comparison.md refresh workflow**: `pnpm run bench:mle && pnpm run bench:checkpoint` (each script writes its sidecar and auto-runs `update:timings`). If on a new machine, also re-run Octave (`pnpm run test:octave`) and update `static-references.json` manually.
  - When **adding** a new timing: (1) add a registry entry to `timing-registry.ts`, (2) call `writeTimingsSidecar` in the relevant script, (3) wrap the .md value with the marker, (4) run `pnpm run update:timings`.
- ESLint plugin: The `@hamk-uas/jax-js-nonconsuming/eslint-plugin` sub-path export enforces correct `using`/disposal patterns. **Always run `pnpm run lint` after editing `src/` files** to catch memory leaks, missing `using` declarations, and use-after-dispose bugs.
- Dependencies: `@hamk-uas/jax-js-nonconsuming` (post-v0.4.0, includes the eslint plugin as a sub-path export) is installed from `github:hamk-uas/jax-js-nonconsuming#767bd260d52ced630d99654edcbb50591f4dc2ac`.
- AD notes: The `using` keyword IS correct inside `grad`/`jit`/`scan` traced bodies ‚Äî tracers intercept disposal and manage tensor lifetimes. Suppression comments (`// jax-js-lint: allow-non-using`) are only needed for the accumulator-swap pattern (e.g. `W_new`, `newContrib` in `src/mle.ts`). See `src/mle.ts` for examples.

Testing & tolerance details (important for PRs) ‚úÖ
- **Eight test suites**: `niledemo.test.ts` (8 tests, Nile data vs Octave), `gensys.test.ts` (47 tests, multi-model vs Octave), `synthetic.test.ts` (24 tests, known true states), `mle.test.ts` (4 tests, MLE parameter & AR coefficient estimation, including missing data, on WASM), `covariate.test.ts` (5 tests, X parameter / Œ≤ recovery), `ozone.test.ts` (2 tests, ozone demo smoke), `forecast.test.ts` (6 tests, h-step-ahead forecasting), `missing.test.ts` (order=1 and order=0 with NaN observations vs Octave reference). Total: 112+ tests (exact count is device-dependent).
- **Tolerances** are defined in `tests/test-matrix.ts`: Float64 relTol=2e-3, absTol=1e-6; Float32 relTol=1e-2, absTol=1e-4. The niledemo test uses tighter ~1e-10 relative tolerance for its specific comparison.
- Test artifacts: failing runs write `tests/out/` ‚Äî inspect JSON files there.
- When adding features: include tests that run in all three modes (`for`, `scan`, `jit`) and add keys to `niledemo-keys.json` if the change is a partial implementation.
- **Float32 + m > 2**: numerically unstable (covariance goes negative ‚Üí NaN). These combinations are skipped in both `gensys.test.ts` and `synthetic.test.ts`.
- **Leak detection**: Wrap jax-js-nonconsuming code in tests with the `withLeakCheck` helper from `tests/utils.ts` (scripts use `scripts/lib/leak-utils.ts`). This helper guards with `checkLeaks.start()`/`checkLeaks.stop()` internally and catches missing `using`/`dispose` calls at runtime. Import: `import { withLeakCheck } from './utils';`. Usage: `const result = await withLeakCheck(() => dlmFit(...));`.
- **Eager-first development**: When writing new jax-js-nonconsuming code, always get it working in eager mode first (no `jit()` wrapper). Only wrap with `jit()` after the eager version is correct and leak-free. JIT adds tracing complexity that makes debugging harder.

Troubleshooting checklist (fast) ü©∫
- Deterministic mismatch? Re-run with CPU+Float64: tests set device via `defaultDevice('cpu')` and `DType.Float64` in the harness.
- Strange memory / nondeterminism? Ensure `using` declarations are present for all temporary `np.Array` values; run `pnpm run lint` to catch missing disposals.
- CI failure on Octave step? Install `octave-cli` locally and run `pnpm run test:octave` to reproduce.
- Want to inspect intermediate arrays? Look at `tests/out/*.json` produced by the test harness.

PR checklist (what an AI should do before opening a PR) üìã
1. Add/modify unit tests covering all modes: `for`, `scan`, `jit` (see `tests/niledemo.test.ts`).
2. If numeric behavior intentionally changes, update or regenerate Octave reference and explain reasoning in the PR description.
3. Update `tests/niledemo-keys.json` when exposing only a subset of outputs.
4. Ensure no new `np.Array` leaks ‚Äî use `using` for temporaries, `tree.dispose()` for bulk cleanup.
5. **Run `pnpm run lint`** to verify the jax-js-nonconsuming eslint plugin reports no memory/disposal issues.
6. Run: `pnpm install && pnpm vitest run && pnpm run test:octave` (if applicable).
7. If public API changes, update `README.md` and TypeScript types in `src/types.ts`.
8. If MLE runtime, convergence, or ‚àí2logL values change: run `pnpm run bench:mle && pnpm run bench:checkpoint` (both auto-patch .md timing/computed markers). If the machine changed, also manually update `assets/timings/static-references.json` with fresh Octave measurements and bump `_measured`.

Example prompts for agents (use these exact templates) ‚úçÔ∏è
- "Add `mode: 'vectorized'` to `dlmFit` implemented via a new helper in `src/index.ts`; add unit tests exercising the new mode and ensure existing `for`/`scan`/`jit` tests still pass. Update README and add entries to `tests/niledemo-keys.json` if output keys change."  
- "Fix a memory leak: find np.Array objects in `src/index.ts` not disposed in all branches and add `using`/`tree.dispose()` with a focused unit test using `withLeakCheck` from `tests/utils.ts` to verify."  
- "Investigate `jit` mismatch on WASM: run the `jit` test twice, capture `tests/out/niledemo-out-jit.json`, and produce a minimal reproducer that highlights the first differing tensor and its path." 

Where agents should open files first (order matters) ‚ñ∂Ô∏è
1. `tests/test-matrix.ts` (shared device √ó dtype configs, tolerances)
2. `tests/niledemo.test.ts` (Nile demo reference test)
3. `src/index.ts` (Kalman filter + RTS smoother, `dlmForecast`, modes, dispose patterns)
4. `src/mle.ts` (MLE parameter estimation via autodiff)
5. `src/dlmgensys.ts` (state space generator)
6. `src/types.ts` (TypedArray shapes, `DlmForecastResult`, helpers)
7. `tests/gensys.test.ts` (multi-model Octave reference tests)
8. `tests/synthetic.test.ts` (ground-truth tests with known true states)
9. `tests/forecast.test.ts` (h-step-ahead forecast tests)
10. `tests/missing.test.ts` (NaN missing-data tests vs Octave reference)

Filesystem safety üìÇ
- **Always use a local `tmp/` directory inside the workspace** for scratch files, debug output, and temporary data. Never write to `/tmp` or any path outside the workspace root. Accessing the filesystem outside the project is risky and breaks agentic coding sandboxes. The `tmp/` directory is already gitignored.

Do not attempt to change (without explicit human approval) üö´
- The Octave reference generator in `tests/octave/` (numerical ground truth). Changes here must be accompanied by a justification and regression analysis.
- Public API shape in `dist/` or `types` unless a major version bump is planned.

Contact & follow-ups
- If anything in the instructions is unclear, ask which *behavior* or *test* to preserve ‚Äî provide the failing `tests/out/*.json` and the test name.

Do not attempt to change (without explicit human approval) üö´
- The Octave reference generator in `tests/octave/` (numerical ground truth). Changes here must be accompanied by a justification and regression analysis.
- Public API shape in `dist/` or `types` unless a major version bump is planned.

Contact & follow-ups
- If anything in the instructions is unclear, ask which *behavior* or *test* to preserve ‚Äî provide the failing `tests/out/*.json` and the test name.