# GitHub Copilot instructions for dlm-js  

Purpose
- Help coding agents become productive immediately: what the project *is*, how it's built/tested, important conventions, and where to look for authoritative behavior.

High-level summary (big picture) üîé
- dlm-js is a TypeScript Kalman filter + RTS smoother library using the `@hamk-uas/jax-js-nonconsuming` numeric backend, inspired by the MATLAB Dynamic Linear Model (DLM). It extends the MATLAB original with autodiff-based MLE (`jit(valueAndGrad + Adam)`) and an exact O(log N) parallel filter+smoother via `lax.associativeScan` (S√§rkk√§ & Garc√≠a-Fern√°ndez 2020). The library exposes CPU/WASM/WebGPU-capable implementations via `dlmFit`/`dlmSmo` (modes: `for`, `scan`, `jit`); note that the WebGPU path is a research/experimental backend ‚Äî dispatch overhead makes it slower than WASM for typical dataset sizes. `dlmForecast` propagates the last smoothed state h steps ahead with no new observations, returning `yhat`, `ystd` (monotonically growing), full state/covariance trajectories, and optional covariate support. `dlmGenSys` generates G/F state-space matrices for polynomial trend, seasonal, and AR components. `dlmMLE` estimates observation noise, state noise, and optionally AR coefficients via autodiff (`jit(valueAndGrad + optax Adam)`, `fitar: true` for AR coefficient estimation).
- **Three-branch execution architecture** in `dlmSmo`: (1) Float64 on any device ‚Üí standard sequential `lax.scan`, (2) Float32 on cpu/wasm ‚Üí sequential scan + Joseph form covariance update + symmetrization, (3) Float32 on webgpu ‚Üí exact parallel method from S√§rkk√§ & Garc√≠a-Fern√°ndez (2020, arXiv:[1905.13002](https://arxiv.org/abs/1905.13002)): exact 5-tuple forward filter (Lemmas 1‚Äì2, per-timestep Kalman gains) + exact parallel backward smoother (Lemmas 5‚Äì6 / Theorem 2), both via `lax.associativeScan` (‚åàlog‚ÇÇN‚åâ+1 GPU dispatches each, Kogge-Stone) + Joseph form. The WebGPU path requires jax-js-nonconsuming v0.7.4 or later (project uses v0.7.7).
- The authoritative numerical reference is generated by Octave (`tests/octave/niledemo.m`, `tests/octave/gensys_tests.m`, `tests/octave/missingdata_test.m`) and compared in `tests/niledemo.test.ts`, `tests/gensys.test.ts`, and `tests/missing.test.ts`. Synthetic ground-truth tests in `tests/synthetic.test.ts` verify against mathematically known true states.

Quick start ‚Äî commands you will need (copy/paste) ‚ñ∂Ô∏è
- Install: `pnpm install`.
- Run node tests (uses source TS): `pnpm vitest run` or `pnpm run test:node`.
- Lint (jax-js-nonconsuming memory rules): `pnpm run lint`.
- Generate API docs: `pnpm run docs` (outputs to `docs/`, opens at `docs/index.html`).
- Generate Octave reference (requires `octave-cli`): `pnpm run test:octave` (produces `tests/*-out-m.json`).
- Generate SVG plots: `pnpm run gen:svg` (produces `assets/*.svg`; also writes timing sidecars to `assets/timings/*.json` and auto-patches `<!-- timing:KEY -->` markers in all .md files).
- Update stale timing values in .md files: `pnpm run update:timings` (reads existing sidecars; no re-run). Inspect slots with `pnpm run update:timings:list`. Preview changes without writing with `pnpm run update:timings:dry`.
- Benchmark all MLE comparison-table rows (Nile order=0, Kaisaniemi): `pnpm run bench:mle` (writes `assets/timings/collect-mle-benchmark.json` and auto-patches .md).
- Benchmark `checkpoint` strategies: `pnpm run bench:checkpoint` (writes `assets/timings/bench-checkpoint.json` and auto-patches .md).
- Benchmark cross-backend `dlmFit` (cpu/wasm √ó f32/f64): `pnpm run bench:backends` (writes `assets/timings/bench-backends.json` and auto-patches .md).
- Build for distribution: `pnpm run build`.
- Full CI-local check: `pnpm run test` (runs lint + Octave reference + Node tests).

Files & places to inspect first üìÅ
- Implementation: `src/index.ts` (Kalman filter + RTS smoother, `dlmForecast` h-step-ahead forecast, modes, memory/dispose patterns, API signatures).
- MLE parameter estimation: `src/mle.ts` (`dlmMLE`: autodiff-based MLE via `jit(valueAndGrad + optax Adam)`, AD-safe `buildDiagW`, `buildG` for AR coefficient estimation). Two loss paths: `makeKalmanLoss` (sequential `lax.scan`, CPU/WASM) and `makeKalmanLossAssoc` (`lax.associativeScan`, WebGPU+Float32; uses exact 5-tuple forward filter from [1, Lemmas 1‚Äì2] with per-timestep Kalman gains, regularized inverse + push-through identity in compose). Float-mask blending for NaN (not boolean np.where). Supports `fitar: true` for AR coefficient estimation.
- State space generator: `src/dlmgensys.ts` (polynomial, seasonal, AR component assembly, `findArInds` for AR state indexing).
- Types & helpers: `src/types.ts` (TypedArray usage, `getFloatArrayType`, `DlmForecastResult` interface). `adSafeInv` was removed in v0.7.8: all call sites now use `np.linalg.inv` directly (VJP fixed in jax-js-nonconsuming v0.7.8).
- Test matrix: `tests/test-matrix.ts` (shared device √ó dtype configs and tolerances).
- Tests: `tests/niledemo.test.ts` (Nile demo vs Octave), `tests/gensys.test.ts` (multi-model vs Octave), `tests/synthetic.test.ts` (known true states, statistical assertions), `tests/mle.test.ts` (MLE parameter & AR coefficient estimation on WASM), `tests/covariate.test.ts` (X parameter / Œ≤ recovery), `tests/ozone.test.ts` (ozone demo smoke tests), `tests/forecast.test.ts` (h-step-ahead forecasting: monotone ystd, finite outputs, covariate support, all models), `tests/missing.test.ts` (order=1 and order=0 with NaN observations vs Octave reference), `tests/assocscan.test.ts` (associativeScan path validated against same Octave references on wasm/f64).
- Reference generators: `tests/octave/niledemo.m`, `tests/octave/gensys_tests.m`, `tests/octave/kaisaniemi_demo.m`, `tests/octave/missingdata_test.m` (MATLAB/Octave ground truth).
- SVG generators: `scripts/gen-niledemo-svg.ts`, `scripts/gen-kaisaniemi-svg.ts`, `scripts/gen-trigar-svg.ts`, `scripts/gen-nile-mle-anim-svg.ts` (accepts variant: scan/assoc/webgpu; + `scripts/collect-nile-mle-frames.ts` runs both scan + assocScan variants), `scripts/gen-energy-mle-anim-svg.ts` (accepts variant: scan/assoc/webgpu; + `scripts/collect-energy-mle-frames.ts` runs both variants), `scripts/gen-ozone-svg.ts`, `scripts/gen-missing-svg.ts` (missing-data demo with NaN interpolation and ystd widening).
- Cross-backend benchmark: `scripts/bench-backends.ts` (cpu/wasm √ó f32/f64 `dlmFit` timing ‚Üí `assets/timings/bench-backends.json`).
- MLE comparison: `mle-comparison.md` (dlm-js MLE vs MATLAB DLM parameter estimation, with benchmark timings).
- Upstream issues: `issues/` (precision analysis, WebGPU JIT einsum bug filed to jax-js-nonconsuming). Key resolved/open issues: `jax-js-webgpu-mle-backward-buffer-limit.md` (‚úÖ resolved), `jax-js-webgpu-laxscan-sequential-dispatch.md` (O(n) backward RTS smoother, architectural), `jax-js-linalg-inv-vjp.md` (‚úÖ resolved in v0.7.8: `np.linalg.inv` VJP is now correct; `adSafeInv` workaround removed).
- Build / CI hooks: `package.json`, `vite.config.ts`.

Project-specific conventions & gotchas ‚ö†Ô∏è
- Execution modes: `for` (fastest in interpreter), `scan` (enables JIT/AD), `jit` (jit(scan) ‚Äî fastest after compilation). Tests exercise all three ‚Äî any numeric change must pass all modes.
- Device/dtype behavior: tests pick backend automatically; `webgpu` ‚Üí float32 (more numeric drift), `wasm`/`cpu` ‚Üí float64 preferred for bit-for-bit checks. When debugging flakiness, force CPU + Float64.
- **Three-branch architecture**: `dlmSmo` selects Float64 (no stabilization), cpu/wasm+Float32 (Joseph form), or webgpu+Float32. The WebGPU path uses **exact parallel Kalman filter + smoother** from S√§rkk√§ & Garc√≠a-Fern√°ndez (2020, arXiv:[1905.13002](https://arxiv.org/abs/1905.13002)): (a) forward: exact 5-tuple elements $(A,b,C,\eta,J)$ from Lemmas 1‚Äì2 with per-timestep Kalman gains, composed by `lax.associativeScan(composeForward, elems)` prefix scan using Lemma 2 with regularized inverse + push-through identity; no approximation, (b) backward: exact per-timestep smoother gains $E_k$ from Lemmas 5‚Äì6 / Theorem 2 via batched `np.linalg.inv` (VJP fixed in jax-js v0.7.8; outer Œµ¬∑I regularization is sufficient), composed by `lax.associativeScan(composeBackward, elems, { reverse: true })` suffix scan. Both `dlmFit` and `dlmSmo` accept `forceAssocScan?: boolean` to enable this path on any backend (used by `assocscan.test.ts` to validate against Octave on wasm/f64). The diagnostic recovery maps assocScan filtered states back to MATLAB DLM carry convention: `x_pred[t] = G¬∑x_filt[t-1]`, `C_pred[t] = G¬∑C_filt[t-1]¬∑G' + W`. WASM is ~10‚Äì20√ó faster than CPU for small-matrix dlmFit. Both WebGPU scans dispatch ‚åàlog‚ÇÇN‚åâ+1 GPU kernels (architecturally optimal; WebGPU lacks cross-workgroup sync so Kogge-Stone requires a separate dispatch per round). Caveat: for purely elementwise `fn` bodies, `associativeScan` achieves exactly 1 GPU kernel per round; if `fn` contains reductions (matmul, einsum with inner sum), each round produces additional dispatches.
- Reference-first testing: Octave output is the source of truth. If you change numerics intentionally, regenerate Octave output and update tests with justification.
- Partial-output testing: use `tests/niledemo-keys.json` to limit comparisons for partial implementations.
- Memory management: This project uses `@hamk-uas/jax-js-nonconsuming` which has **non-consuming ops** ‚Äî operations leave inputs intact. Use TC39 `using` keyword for automatic disposal and `tree.dispose()` for bulk cleanup. Do NOT use `.ref` (that is the consuming-ops pattern from a different fork).
- **Timing and computed markers in .md files**: Every machine-dependent value in README.md or mle-comparison.md uses one of two invisible HTML marker forms:
  - `<!-- timing:KEY -->VALUE<!-- /timing -->` ‚Äî replaced with `formatTiming(sidecar[field])` for the named KEY. Registry: `scripts/lib/timing-registry.ts`. Sidecars: `assets/timings/<script-basename>.json`.
  - `<!-- computed:EXPR -->VALUE<!-- /computed -->` ‚Äî EXPR is a JS expression using `slot("KEY")` (raw numeric value from a sidecar) and `static("KEY")` (value from `assets/timings/static-references.json`). Used for derived verbal claims, e.g. `static("octave-nile-order1-elapsed-ms") < slot("nile-mle:elapsed") ? "faster" : "slower"` or `Math.abs(slot("mle-bench:nile-order1:lik") - static("octave-nile-order1-lik")).toFixed(1)`.
  - `assets/timings/static-references.json` holds **manually-measured Octave** fminsearch timings and ‚àí2logL values. The `machine` field is auto-updated by `stampMachineInfo()` (called by `bench:mle` and `bench:checkpoint`). Update the Octave timing fields and `_measured` date manually whenever Octave is re-run on a different machine.
  - Both marker types are patched by a single `pnpm run update:timings` call after any sidecar or static-references change.
  - **Full mle-comparison.md refresh workflow**: `pnpm run bench:mle && pnpm run bench:checkpoint` (each script writes its sidecar and auto-runs `update:timings`). If on a new machine, also re-run Octave (`pnpm run test:octave`) and update `static-references.json` manually.
  - When **adding** a new timing: (1) add a registry entry to `timing-registry.ts`, (2) call `writeTimingsSidecar` in the relevant script, (3) wrap the .md value with the marker, (4) run `pnpm run update:timings`.
- ESLint plugin: The `@hamk-uas/jax-js-nonconsuming/eslint-plugin` sub-path export enforces correct `using`/disposal patterns. **Always run `pnpm run lint` after editing `src/` files** to catch memory leaks, missing `using` declarations, and use-after-dispose bugs.
- Dependencies: `@hamk-uas/jax-js-nonconsuming` v0.7.7 (includes the eslint plugin as a sub-path export) is installed from `github:hamk-uas/jax-js-nonconsuming#v0.7.7`.
- AD notes: The `using` keyword IS correct inside `grad`/`jit`/`scan` traced bodies ‚Äî tracers intercept disposal and manage tensor lifetimes. Suppression comments (`// jax-js-lint: allow-non-using`) are only needed for the accumulator-swap pattern (e.g. `W_new`, `newContrib` in `src/mle.ts`). See `src/mle.ts` for examples.

Testing & tolerance details (important for PRs) ‚úÖ
- **Nine test suites**: `niledemo.test.ts` (8 tests, Nile data vs Octave), `gensys.test.ts` (47 tests, multi-model vs Octave), `synthetic.test.ts` (24 tests, known true states), `mle.test.ts` (4 tests, MLE parameter & AR coefficient estimation, including missing data, on WASM), `covariate.test.ts` (5 tests, X parameter / Œ≤ recovery), `ozone.test.ts` (2 tests, ozone demo smoke), `forecast.test.ts` (6 tests, h-step-ahead forecasting), `missing.test.ts` (order=1 and order=0 with NaN observations vs Octave reference), `assocscan.test.ts` (24 tests, associativeScan path validated against same Octave references on wasm/f64 ‚Äî covers all gensys models, Nile demo, and missing data). Total: 136 tests.
- **Tolerances** are defined in `tests/test-matrix.ts`: Float64 relTol=2e-3, absTol=1e-6; Float32 relTol=1e-2, absTol=1e-4. The niledemo test uses tighter ~1e-10 relative tolerance for its specific comparison.
- Test artifacts: failing runs write `tests/out/` ‚Äî inspect JSON files there.
- When adding features: include tests that run in all three modes (`for`, `scan`, `jit`) and add keys to `niledemo-keys.json` if the change is a partial implementation.
- **Float32 + m > 2**: numerically unstable (covariance goes negative ‚Üí NaN). These combinations are skipped in both `gensys.test.ts` and `synthetic.test.ts`.
- **Leak detection**: Wrap jax-js-nonconsuming code in tests with the `withLeakCheck` helper from `tests/utils.ts` (scripts use `scripts/lib/leak-utils.ts`). This helper guards with `checkLeaks.start()`/`checkLeaks.stop()` internally and catches missing `using`/`dispose` calls at runtime. Import: `import { withLeakCheck } from './utils';`. Usage: `const result = await withLeakCheck(() => dlmFit(...));`.
- **Eager-first development**: When writing new jax-js-nonconsuming code, always get it working in eager mode first (no `jit()` wrapper). Only wrap with `jit()` after the eager version is correct and leak-free. JIT adds tracing complexity that makes debugging harder.

Troubleshooting checklist (fast) ü©∫
- Deterministic mismatch? Re-run with CPU+Float64: tests set device via `defaultDevice('cpu')` and `DType.Float64` in the harness.
- Strange memory / nondeterminism? Ensure `using` declarations are present for all temporary `np.Array` values; run `pnpm run lint` to catch missing disposals.
- CI failure on Octave step? Install `octave-cli` locally and run `pnpm run test:octave` to reproduce.
- Want to inspect intermediate arrays? Look at `tests/out/*.json` produced by the test harness.

PR checklist (what an AI should do before opening a PR) üìã
1. Add/modify unit tests covering all modes: `for`, `scan`, `jit` (see `tests/niledemo.test.ts`).
2. If numeric behavior intentionally changes, update or regenerate Octave reference and explain reasoning in the PR description.
3. Update `tests/niledemo-keys.json` when exposing only a subset of outputs.
4. Ensure no new `np.Array` leaks ‚Äî use `using` for temporaries, `tree.dispose()` for bulk cleanup.
5. **Run `pnpm run lint`** to verify the jax-js-nonconsuming eslint plugin reports no memory/disposal issues.
6. Run: `pnpm install && pnpm vitest run && pnpm run test:octave` (if applicable).
7. If public API changes, update `README.md` and TypeScript types in `src/types.ts`.
8. If MLE runtime, convergence, or ‚àí2logL values change: run `pnpm run bench:mle && pnpm run bench:checkpoint` (both auto-patch .md timing/computed markers). If the machine changed, also manually update `assets/timings/static-references.json` with fresh Octave measurements and bump `_measured`.

Example prompts for agents (use these exact templates) ‚úçÔ∏è
- "Add `mode: 'vectorized'` to `dlmFit` implemented via a new helper in `src/index.ts`; add unit tests exercising the new mode and ensure existing `for`/`scan`/`jit` tests still pass. Update README and add entries to `tests/niledemo-keys.json` if output keys change."  
- "Fix a memory leak: find np.Array objects in `src/index.ts` not disposed in all branches and add `using`/`tree.dispose()` with a focused unit test using `withLeakCheck` from `tests/utils.ts` to verify."  
- "Investigate `jit` mismatch on WASM: run the `jit` test twice, capture `tests/out/niledemo-out-jit.json`, and produce a minimal reproducer that highlights the first differing tensor and its path." 

Where agents should open files first (order matters) ‚ñ∂Ô∏è
1. `tests/test-matrix.ts` (shared device √ó dtype configs, tolerances)
2. `tests/niledemo.test.ts` (Nile demo reference test)
3. `src/index.ts` (Kalman filter + RTS smoother, `dlmForecast`, modes, dispose patterns)
4. `src/mle.ts` (MLE parameter estimation via autodiff)
5. `src/dlmgensys.ts` (state space generator)
6. `src/types.ts` (TypedArray shapes, `DlmForecastResult`, helpers)
7. `tests/gensys.test.ts` (multi-model Octave reference tests)
8. `tests/synthetic.test.ts` (ground-truth tests with known true states)
9. `tests/forecast.test.ts` (h-step-ahead forecast tests)
10. `tests/missing.test.ts` (NaN missing-data tests vs Octave reference)

Filesystem safety üìÇ
- **Always use a local `tmp/` directory inside the workspace** for scratch files, debug output, and temporary data. This applies to everything: log files, benchmark output, background process redirection, debug traces, repro scripts ‚Äî all of it goes in `tmp/`.
- **Never write to `/tmp`, `$HOME`, or any path outside the workspace root.** Accessing the filesystem outside the project is risky and breaks agentic coding sandboxes.
- The `tmp/` directory is already gitignored. Example: redirect background benchmark output to `tmp/bench-mle.log`, not `/tmp/bench-mle.log`.

Do not attempt to change (without explicit human approval) üö´
- The Octave reference generator in `tests/octave/` (numerical ground truth). Changes here must be accompanied by a justification and regression analysis.
- Public API shape in `dist/` or `types` unless a major version bump is planned.

Contact & follow-ups
- If anything in the instructions is unclear, ask which *behavior* or *test* to preserve ‚Äî provide the failing `tests/out/*.json` and the test name.

Do not attempt to change (without explicit human approval) üö´
- The Octave reference generator in `tests/octave/` (numerical ground truth). Changes here must be accompanied by a justification and regression analysis.
- Public API shape in `dist/` or `types` unless a major version bump is planned.

Contact & follow-ups
- If anything in the instructions is unclear, ask which *behavior* or *test* to preserve ‚Äî provide the failing `tests/out/*.json` and the test name.