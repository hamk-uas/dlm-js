# GitHub Copilot instructions for dlm-js  

Purpose
- Help coding agents become productive immediately: what the project *is*, how it's built/tested, important conventions, and where to look for authoritative behavior.

High-level summary (big picture) üîé
- dlm-js is a computation-only TypeScript port of a MATLAB Dynamic Linear Model (DLM) using the `@jax-js/jax` numeric backend. The library implements Kalman filter + RTS smoother and exposes CPU/WASM/WebGPU-capable implementations via `dlmFit`/`dlmSmo` (modes: `for`, `scan`, `jit`).
- The authoritative numerical reference is generated by Octave (`tests/octave/niledemo.m`) and compared in `tests/niledemo.test.ts`.

Quick start ‚Äî commands you will need (copy/paste) ‚ñ∂Ô∏è
- Install: `pnpm install` (project expects a local `../jax-js` during active development ‚Äî package.json uses `link:../jax-js`).
- Run node tests (uses source TS): `pnpm vitest run` or `pnpm run test:node`.
- Generate Octave reference (requires `octave-cli`): `npm run test:octave` (produces `tests/niledemo-out-m.json`).
- Build for distribution: `npm run build`.
- Full CI-local check: `npm run test` (runs Octave reference + Node tests).

Files & places to inspect first üìÅ
- Implementation: `src/index.ts` (modes, memory/dispose patterns, API signatures).
- Types & helpers: `src/types.ts` (TypedArray usage, `getFloatArrayType`).
- Tests (golden + harness): `tests/niledemo.test.ts`, `tests/niledemo-in.json`, `tests/niledemo-out-m.json`, `tests/niledemo-keys.json`, `tests/out/`.
- Reference generator: `tests/octave/niledemo.m` (MATLAB/Octave ground truth).
- Design notes: `scan-implementation.md` (important for `lax.scan`/JIT nuances).
- Build / CI hooks: `package.json`, `vite.config.ts`.

Project-specific conventions & gotchas ‚ö†Ô∏è
- Execution modes: `for` (fastest in interpreter), `scan` (enables JIT/AD), `jit` (jit(scan) ‚Äî fastest after compilation). Tests exercise all three ‚Äî any numeric change must pass all modes.
- Device/dtype behavior: tests pick backend automatically; `webgpu` ‚Üí float32 (more numeric drift), `wasm`/`cpu` ‚Üí float64 preferred for bit-for-bit checks. When debugging flakiness, force CPU + Float64.
- Reference-first testing: Octave output is the source of truth. If you change numerics intentionally, regenerate Octave output and update tests with justification.
- Partial-output testing: use `tests/niledemo-keys.json` to limit comparisons for partial implementations.
- Memory management: `np.Array` wrappers must be disposed. Use `.ref` when a value is reused (see `src/index.ts` patterns).
- Local dependency: `@jax-js/jax` is linked locally during development (`link:../jax-js`). Ensure the sibling repo is present or update dependency for isolated debugging.

Testing & tolerance details (important for PRs) ‚úÖ
- Tests compare JSON outputs with a **relative tolerance** of ~1e-10 (see `tests/niledemo.test.ts` and `tests/utils.ts`). Small dtype/device changes can trigger failures.
- Test artifacts: failing runs write `tests/out/niledemo-out-<mode>.json` ‚Äî inspect these alongside `tests/niledemo-out-m.json`.
- When adding features: include tests that run in all three modes (`for`, `scan`, `jit`) and add keys to `niledemo-keys.json` if the change is a partial implementation.

Troubleshooting checklist (fast) ü©∫
- Deterministic mismatch? Re-run with CPU+Float64: tests set device via `defaultDevice('cpu')` and `DType.Float64` in the harness.
- CI failure on Octave step? Install `octave-cli` locally and run `npm run test:octave` to reproduce.
- Want to inspect intermediate arrays? Look at `tests/out/*.json` produced by the test harness.

PR checklist (what an AI should do before opening a PR) üìã
1. Add/modify unit tests covering all modes: `for`, `scan`, `jit` (see `tests/niledemo.test.ts`).
2. If numeric behavior intentionally changes, update or regenerate Octave reference and explain reasoning in the PR description.
3. Update `tests/niledemo-keys.json` when exposing only a subset of outputs.
4. Ensure no new `np.Array` leaks.
5. Run: `pnpm install && pnpm vitest run && npm run test:octave` (if applicable).
6. If public API changes, update `README.md` and TypeScript types in `src/types.ts`.

Example prompts for agents (use these exact templates) ‚úçÔ∏è
- "Add `mode: 'vectorized'` to `dlmFit` implemented via a new helper in `src/index.ts`; add unit tests exercising the new mode and ensure existing `for`/`scan`/`jit` tests still pass. Update README and add entries to `tests/niledemo-keys.json` if output keys change."  
- "Investigate `jit` mismatch on WASM: run the `jit` test twice, capture `tests/out/niledemo-out-jit.json`, and produce a minimal reproducer that highlights the first differing tensor and its path." 

Where agents should open files first (order matters) ‚ñ∂Ô∏è
1. `tests/niledemo.test.ts` (test harness & tolerances)
2. `src/index.ts` (implementation, modes, dispose patterns)
3. `src/types.ts` (TypedArray shapes, helpers)
4. `tests/octave/niledemo.m` (ground-truth generator)
5. `scan-implementation.md` (lax.scan/JIT architecture notes)

Do not attempt to change (without explicit human approval) üö´
- The Octave reference generator in `tests/octave/` (numerical ground truth). Changes here must be accompanied by a justification and regression analysis.
- Public API shape in `dist/` or `types` unless a major version bump is planned.

Contact & follow-ups
- If anything in the instructions is unclear, ask which *behavior* or *test* to preserve ‚Äî provide the failing `tests/out/*.json` and the test name.