/**
 * Stratospheric ozone trend analysis — replication of the MATLAB DLM demo.
 *
 * Reference: Laine, Latva-Pukkila & Kyrölä (2014), "Analyzing time-varying trends
 * in stratospheric ozone time series using state space approach",
 * Atmospheric Chemistry and Physics 14(18), doi:10.5194/acp-14-9707-2014.
 *
 * Data: ozonedata.dat (from https://github.com/mjlaine/dlm/tree/master/examples)
 *   col 1  decimal year (1984–2011)
 *   col 2  ozone density [1/cm³], NaN where missing
 *   col 3  uncertainty σ [1/cm³], NaN where missing
 *   col 4  solar proxy  (normalised F10.7-like index)
 *   col 5  QBO component 1
 *   col 6  QBO component 2
 *
 * Model (matches MATLAB options = struct('trig',2,'order',1) + 3 proxy covariates):
 *   y_t = μ_t + γ_t + β₁·solar + β₂·qbo1 + β₃·qbo2 + ε
 *   μ_t = μ_{t-1} + α_{t-1} + η_μ,   α_t = α_{t-1} + η_α   (local linear trend)
 *   γ_t = 2 trig harmonics for monthly seasonality (ns=12)
 *
 * Usage:  npx tsx scripts/gen-ozone-svg.ts
 * Output: assets/ozone-demo.svg
 */

import { readFileSync } from "node:fs";
import { resolve, dirname } from "node:path";
import { dlmFit, dlmForecast } from "../src/index.ts";
import { defaultDevice, DType } from "@hamk-uas/jax-js-nonconsuming";

defaultDevice("wasm");

const variant = process.argv[2] === 'assoc' ? 'assoc' : 'scan';
const isAssoc = variant === 'assoc';
const scanLabel = isAssoc ? 'assocScan/WASM/f64' : 'WASM/f64';

import {
  r, makeLinearScale, polylinePoints, bandPathD,
  renderGridLines, renderYAxis, renderXAxis, renderAxesBorder, writeSvg,
  yTicksFromRange,
} from "./lib/svg-helpers.ts";
import { withLeakCheck } from "./lib/leak-utils.ts";

// ── Load data ─────────────────────────────────────────────────────────────
const root = resolve(dirname(new URL(import.meta.url).pathname), "..");

// MATLAB/Octave reference (generated by tests/octave/ozonedemo.m)
const mRef = JSON.parse(readFileSync(resolve(root, "tests/ozone-out-m.json"), "utf8"));
const mInp = JSON.parse(readFileSync(resolve(root, "tests/ozone-in.json"),    "utf8"));
const m_ys: number = mInp.ys;  // scale factor used by Octave
const raw = readFileSync(resolve(root, "tests/ozonedata.dat"), "utf8");

const rows = raw.trim().split("\n").map(line =>
  line.trim().split(/\s+/).map(v => (v === "NaN" ? NaN : parseFloat(v)))
);

const time   = rows.map(r => r[0]);  // decimal year
const y_raw  = rows.map(r => r[1]);  // ozone [1/cm³]
const s_raw  = rows.map(r => r[2]);  // uncertainty σ
const solar  = rows.map(r => r[3]);  // solar proxy
const qbo1   = rows.map(r => r[4]);  // QBO component 1
const qbo2   = rows.map(r => r[5]);  // QBO component 2
const N      = time.length;

// Load scaled yy / ss exactly as Octave prepared them (same stdnan scaling,
// same missing-data fill: y→ym, s→ss_med).  This ensures dlm-js and MATLAB
// run the identical numerical problem so their outputs are directly comparable.
const ys: number = mInp.ys;
const ym: number = mInp.ym;
const y_filled: number[] = Array.from(mInp.yy as number[]);
const s_filled: number[] = Array.from(mInp.ss as number[]);

// Covariates matrix: X[t] = [solar(t), qbo1(t), qbo2(t)] — proxies always observed
const X: number[][] = time.map((_, i) => [solar[i], qbo1[i], qbo2[i]]);

// ── Fit DLM ───────────────────────────────────────────────────────────────
// Match MATLAB: options = struct('trig',2,'order',1)
// order=1 → local linear trend (2 states: level + slope)
// trig=2  → 2 harmonics for ns=12 monthly seasons (4 states: 2×[cos,sin])
// 3 proxy covariates → 3 static β states
// Total state dimension: 2 + 4 + 3 = 9

// w = [level_std=0, trend_std, seas1_std, seas1*_std, seas2_std, seas2*_std]
const w: number[] = Array.from(mInp.w as number[]);

console.log(`Fitting DLM: N=${N} months (${time[0].toFixed(2)}–${time[N-1].toFixed(2)})`);
console.log(`  ys=${ys.toExponential(3)}, ym=${ym.toFixed(4)}, w=[${w.map(v=>v.toExponential(2)).join(',')}]`);

const fit = await withLeakCheck(() =>
  dlmFit(
    y_filled, s_filled, w, DType.Float64,
    { order: 1, trig: 2 },
    X,
    isAssoc,
  )
);

// State layout (order=1, trig=2, q=3):
//  x[0] = μ (level)
//  x[1] = α (trend slope)
//  x[2], x[3] = harmonic 1 (annual, cos/sin pair)
//  x[4], x[5] = harmonic 2 (semi-annual)
//  x[6] = β_solar
//  x[7] = β_qbo1
//  x[8] = β_qbo2

const mu_hat   = Array.from(fit.x[0]).map(v => v * ys);     // level [1/cm³]
const mu_std   = fit.xstd.map(row => row[0] * ys);
const beta_solar = Array.from(fit.x[6]);
const beta_qbo1  = Array.from(fit.x[7]);
const beta_qbo2  = Array.from(fit.x[8]);

const beta_solar_f = beta_solar[N - 1];
const beta_qbo1_f  = beta_qbo1[N - 1];
const beta_qbo2_f  = beta_qbo2[N - 1];
console.log(`  β_solar=${(beta_solar_f * ys).toExponential(3)}`);
console.log(`  β_qbo1 =${(beta_qbo1_f  * ys).toExponential(3)}`);
console.log(`  β_qbo2 =${(beta_qbo2_f  * ys).toExponential(3)}`);

// ── h-step-ahead forecast ─────────────────────────────────────────────────
// Forecast 36 months (3 years) ahead with no covariate information (X_forecast = zero rows).
// This shows the pure trend + seasonal component extrapolation.
// Use median of s_filled as the representative scalar observation noise std.
const s_median = [...s_filled].sort((a, b) => a - b)[Math.floor(s_filled.length / 2)];
const H_FORE = 180;  // 15 years
const X_forecast_zero = Array.from({ length: H_FORE }, () => [0, 0, 0]);
const fore = await withLeakCheck(() =>
  dlmForecast(fit, s_median, H_FORE, DType.Float64, X_forecast_zero)
);

// Build forecast time axis (monthly steps from end of data)
const dt = 1 / 12;  // one month in decimal years
const foreTime: number[] = Array.from({ length: H_FORE }, (_, k) => time[N - 1] + (k + 1) * dt);

// Forecast level (state 0) ± 2σ (back-scaled).
// We use the level state x[0] rather than the full observation prediction yhat,
// because yhat = F·x_pred includes the oscillating seasonal harmonics — which
// would make the "trend forecast" look like a 36-month seasonal projection
// rather than a smooth trendline. The level state is the quantity the paper
// actually analyses (the long-term ozone trend).
const fore_level: number[] = Array.from(fore.x[0]).map(v => v * ys);
const fore_level_std: number[] = fore.xstd.map(row => row[0] * ys);
const fore_upper = fore_level.map((v, i) => v + 2 * fore_level_std[i]);
const fore_lower = fore_level.map((v, i) => v - 2 * fore_level_std[i]);

console.log(`  Forecast ${H_FORE} months: level[0]=${fore_level[0].toExponential(3)} std[0]=${fore_level_std[0].toExponential(3)} std[-1]=${fore_level_std[H_FORE-1].toExponential(3)}`);

// Back-scale level and band
const mu_upper = mu_hat.map((v, i) => v + 2 * mu_std[i]);
const mu_lower = mu_hat.map((v, i) => v - 2 * mu_std[i]);

// Proxy contributions [1/cm³]
const contrib_solar: number[] = time.map((_, i) => beta_solar[i] * solar[i] * ys);
const contrib_qbo1:  number[] = time.map((_, i) => beta_qbo1[i]  * qbo1[i]  * ys);
const contrib_qbo2:  number[] = time.map((_, i) => beta_qbo2[i]  * qbo2[i]  * ys);
const contrib_qbo:   number[] = contrib_qbo1.map((v, i) => v + contrib_qbo2[i]);

// Observations (back-scaled, NaN where missing — use raw y_raw for NaN mask)
const y_sc = y_raw.map(v => (isFinite(v) ? v : NaN));

// ── MATLAB reference curves (back-scaled) ────────────────────────────────
// mRef.x is [m][N] (MATLAB row-major: m states × N timesteps)
const m_level:  number[] = (mRef.x[0] as number[]).map(v => v * m_ys);
const m_level_std: number[] = (mRef.xstd as number[][]).map(row => row[0] * m_ys);
const m_level_upper = m_level.map((v, i) => v + 2 * m_level_std[i]);
const m_level_lower = m_level.map((v, i) => v - 2 * m_level_std[i]);

const m_beta_solar = mRef.x[6] as number[];
const m_beta_qbo1  = mRef.x[7] as number[];
const m_beta_qbo2  = mRef.x[8] as number[];
const m_contrib_solar: number[] = time.map((_, i) => m_beta_solar[i] * solar[i] * m_ys);
const m_contrib_qbo:   number[] = time.map((_, i) =>
  (m_beta_qbo1[i] * qbo1[i] + m_beta_qbo2[i] * qbo2[i]) * m_ys
);

// ── SVG layout ────────────────────────────────────────────────────────────
const margin = { top: 30, right: 22, bottom: 50, left: 68 };
const panelGap = 55;
const W = 900;
const panelH = 230;
const H = margin.top + panelH + panelGap + panelH + margin.bottom;
const plotW = W - margin.left - margin.right;

// x-axis extends to end of forecast period
const xEnd = foreTime[H_FORE - 1];
const sx = makeLinearScale(time[0], xEnd, margin.left, margin.left + plotW);

// x-axis ticks: every 2 years including forecast years
const xTickYears: number[] = [];
for (let yr = Math.ceil(time[0]); yr <= Math.floor(xEnd); yr++) {
  if ((yr - 1984) % 2 === 0) xTickYears.push(yr);
}
const xTickObjs = xTickYears.map(yr => ({ val: yr, label: `${yr}` }));

// ── Panel 1: observations + smoothed level ────────────────────────────────
const p1Top = margin.top;
const p1Bot = margin.top + panelH;

// Build finite observation lists for polyline rendering (skip NaN spans)
function finiteSegments(xs: number[], ys_: number[]): string {
  const pts: string[] = [];
  for (let i = 0; i < xs.length; i++) {
    if (isFinite(ys_[i])) pts.push(`${r(sx(xs[i]))},${r(sy1(ys_[i]))}`);
  }
  return pts.join(" ");
}

// Y range from observations + both bands + forecast
const allP1 = [...y_sc.filter(isFinite), ...mu_upper, ...mu_lower, ...m_level_upper, ...m_level_lower, ...fore_upper, ...fore_lower];
const y1Min = Math.floor(Math.min(...allP1) / 2e9) * 2e9;
const y1Max = Math.ceil(Math.max(...allP1)  / 2e9) * 2e9;
const sy1 = makeLinearScale(y1Min, y1Max, p1Bot, p1Top);

// Y ticks in units of 1e10
const y1Step = (y1Max - y1Min) > 2e10 ? 1e10 : 5e9;
const yTicks1Raw: number[] = [];
for (let v = Math.ceil((y1Min) / y1Step) * y1Step; v <= y1Max; v += y1Step) {
  yTicks1Raw.push(v);
}

// ── Panel 2: proxy contributions ─────────────────────────────────────────
const p2Top = margin.top + panelH + panelGap;
const p2Bot = margin.top + panelH + panelGap + panelH;

const allP2 = [...contrib_solar, ...contrib_qbo, ...m_contrib_solar, ...m_contrib_qbo];
const p2Abs = Math.ceil(Math.max(...allP2.map(Math.abs)) / 1e9) * 1e9;
const y2Min = -p2Abs, y2Max = p2Abs;
const sy2 = makeLinearScale(y2Min, y2Max, p2Bot, p2Top);
const y2Step = p2Abs > 4e9 ? 2e9 : 1e9;
const yTicks2Raw: number[] = [];
for (let v = Math.ceil(y2Min / y2Step) * y2Step; v <= y2Max; v += y2Step) {
  yTicks2Raw.push(v);
}

// Format ticks as ×10¹⁰
const fmt1 = (v: number): string => (v / 1e10).toFixed(1);
const fmt2 = (v: number): string => (v / 1e9).toFixed(0);

// ── Build SVG ─────────────────────────────────────────────────────────────
const svg: string[] = [
  `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${W} ${H}" font-family="system-ui,-apple-system,sans-serif" font-size="12">`,
  `<rect width="${W}" height="${H}" fill="white"/>`,
];

// ── Panel 1 ──────────────────────────────────────────────────────────────
svg.push(...renderGridLines(yTicks1Raw, sy1, margin.left, margin.left + plotW));

// Shaded forecast region (light grey background)
const xForeStart = r(sx(time[N - 1]));
const xForeEnd   = r(sx(foreTime[H_FORE - 1]));
svg.push(`<rect x="${xForeStart}" y="${p1Top}" width="${xForeEnd - xForeStart}" height="${panelH}" fill="#f3f4f6" fill-opacity="0.7"/>`);

// ±2σ band — dlm-js (blue)
svg.push(`<path d="${bandPathD(time, mu_upper, mu_lower, sx, sy1)}" fill="#3b82f6" fill-opacity="0.15" stroke="none"/>`);

// Observations
{
  const pts: string[] = [];
  for (let i = 0; i < N; i++) {
    if (isFinite(y_sc[i])) pts.push(`${r(sx(time[i]))},${r(sy1(y_sc[i]))}`);
  }
  svg.push(`<polyline points="${pts.join(" ")}" fill="none" stroke="#9ca3af" stroke-width="1" opacity="0.6"/>`);
}

// dlm-js smoothed level — solid blue
svg.push(`<polyline points="${polylinePoints(time, mu_hat, sx, sy1)}" fill="none" stroke="#2563eb" stroke-width="2.2"/>`);
// ±2σ band — MATLAB (red, on top of blue band)
svg.push(`<path d="${bandPathD(time, m_level_upper, m_level_lower, sx, sy1)}" fill="#ef4444" fill-opacity="0.15" stroke="none"/>`);
// MATLAB smoothed level — dashed red (drawn last, always visible)
svg.push(`<polyline points="${polylinePoints(time, m_level, sx, sy1)}" fill="none" stroke="#dc2626" stroke-width="2" stroke-dasharray="6 3"/>`);

// ── Forecast rendering ───────────────────────────────────────────────────
// Growing ±2σ level-state uncertainty band (green tint)
svg.push(`<path d="${bandPathD(foreTime, fore_upper, fore_lower, sx, sy1)}" fill="#22c55e" fill-opacity="0.18" stroke="none"/>`);
// Forecast level trend — dashed green
svg.push(`<polyline points="${polylinePoints(foreTime, fore_level, sx, sy1)}" fill="none" stroke="#16a34a" stroke-width="2" stroke-dasharray="5 3"/>`);
// Vertical end-of-data marker
svg.push(`<line x1="${xForeStart}" y1="${p1Top}" x2="${xForeStart}" y2="${p1Bot}" stroke="#6b7280" stroke-width="1" stroke-dasharray="3 2"/>`);

// Axes
svg.push(...renderYAxis(yTicks1Raw, sy1, margin.left, fmt1));
svg.push(...renderXAxis(xTickObjs, sx, p1Bot));
svg.push(...renderAxesBorder(margin.left, p1Top, margin.left + plotW, p1Bot));

// Y-axis title (×10¹⁰ cm⁻³)
svg.push(`<text transform="rotate(-90)" x="${-(p1Top + panelH / 2)}" y="${margin.left - 52}" text-anchor="middle" fill="#374151" font-size="11">O₃ density [×10¹⁰ cm⁻³]</text>`);

// Legend
const l1x = margin.left + plotW - 262, l1y = p1Top + 14;
svg.push(`<line x1="${l1x}" y1="${l1y}" x2="${l1x+22}" y2="${l1y}" stroke="#9ca3af" stroke-width="1"/>`);
svg.push(`<text x="${l1x+27}" y="${l1y+4}" fill="#374151" font-size="11">Observations (SAGE II / GOMOS)</text>`);
svg.push(`<line x1="${l1x}" y1="${l1y+15}" x2="${l1x+22}" y2="${l1y+15}" stroke="#2563eb" stroke-width="2.2"/>`);
svg.push(`<text x="${l1x+27}" y="${l1y+19}" fill="#374151" font-size="11">dlm-js smoothed level ±2σ</text>`);
svg.push(`<line x1="${l1x}" y1="${l1y+30}" x2="${l1x+22}" y2="${l1y+30}" stroke="#dc2626" stroke-width="1.8" stroke-dasharray="5 3"/>`);
svg.push(`<text x="${l1x+27}" y="${l1y+34}" fill="#374151" font-size="11">MATLAB/Octave reference ±2σ</text>`);
svg.push(`<line x1="${l1x}" y1="${l1y+45}" x2="${l1x+22}" y2="${l1y+45}" stroke="#16a34a" stroke-width="1.8" stroke-dasharray="5 3"/>`);
svg.push(`<text x="${l1x+27}" y="${l1y+49}" fill="#374151" font-size="11">15-year trend forecast ±2σ (level state)</text>`);

// Title
svg.push(`<text x="${margin.left + plotW / 2}" y="${p1Top - 10}" text-anchor="middle" fill="#374151" font-size="13" font-weight="bold">Stratospheric ozone (45–55 km, 40°N–50°N) — fit (order=1, trig=2, ns=12, 3 covariates) + 15y forecast, ${scanLabel}</text>`);

// ── Panel 2 ──────────────────────────────────────────────────────────────
svg.push(...renderGridLines(yTicks2Raw, sy2, margin.left, margin.left + plotW));
svg.push(`<line x1="${margin.left}" y1="${r(sy2(0))}" x2="${margin.left+plotW}" y2="${r(sy2(0))}" stroke="#6b7280" stroke-width="0.8" stroke-dasharray="2 2"/>`);

// Solar contribution — dlm-js (solid)
svg.push(`<polyline points="${polylinePoints(time, contrib_solar, sx, sy2)}" fill="none" stroke="#f59e0b" stroke-width="1.8"/>`);
// QBO total — dlm-js (solid)
svg.push(`<polyline points="${polylinePoints(time, contrib_qbo, sx, sy2)}" fill="none" stroke="#8b5cf6" stroke-width="1.8"/>`);
// Solar contribution — MATLAB (dashed, on top)
svg.push(`<polyline points="${polylinePoints(time, m_contrib_solar, sx, sy2)}" fill="none" stroke="#dc2626" stroke-width="2" stroke-dasharray="6 3"/>`);
// QBO total — MATLAB (dotted, on top)
svg.push(`<polyline points="${polylinePoints(time, m_contrib_qbo, sx, sy2)}" fill="none" stroke="#dc2626" stroke-width="2" stroke-dasharray="2 3"/>`);

// Axes
svg.push(...renderYAxis(yTicks2Raw, sy2, margin.left, fmt2));
svg.push(...renderXAxis(xTickObjs, sx, p2Bot));
svg.push(...renderAxesBorder(margin.left, p2Top, margin.left + plotW, p2Bot));

// Y-axis title
svg.push(`<text transform="rotate(-90)" x="${-(p2Top + panelH / 2)}" y="${margin.left - 52}" text-anchor="middle" fill="#374151" font-size="11">Contribution [×10⁹ cm⁻³]</text>`);

// x-axis label
svg.push(`<text x="${margin.left + plotW / 2}" y="${p2Bot + 38}" text-anchor="middle" fill="#4b5563" font-size="11">Year</text>`);

// Legend
const l2x = margin.left + 10, l2y = p2Top + 14;
svg.push(`<line x1="${l2x}" y1="${l2y}" x2="${l2x+22}" y2="${l2y}" stroke="#f59e0b" stroke-width="1.8"/>`);
svg.push(`<text x="${l2x+27}" y="${l2y+4}" fill="#374151" font-size="11">dlm-js solar β̂·X_solar</text>`);
svg.push(`<line x1="${l2x}" y1="${l2y+15}" x2="${l2x+22}" y2="${l2y+15}" stroke="#8b5cf6" stroke-width="1.8"/>`);
svg.push(`<text x="${l2x+27}" y="${l2y+19}" fill="#374151" font-size="11">dlm-js QBO β̂_qbo1·X₁ + β̂_qbo2·X₂</text>`);
svg.push(`<line x1="${l2x}" y1="${l2y+30}" x2="${l2x+22}" y2="${l2y+30}" stroke="#dc2626" stroke-width="1.4" stroke-dasharray="5 3"/>`);
 svg.push(`<text x="${l2x+27}" y="${l2y+34}" fill="#374151" font-size="11">MATLAB solar (reference)</text>`);
svg.push(`<line x1="${l2x}" y1="${l2y+45}" x2="${l2x+22}" y2="${l2y+45}" stroke="#dc2626" stroke-width="1.4" stroke-dasharray="2 3"/>`);
svg.push(`<text x="${l2x+27}" y="${l2y+49}" fill="#374151" font-size="11">MATLAB QBO (reference)</text>`);

// Panel 2 title
svg.push(`<text x="${margin.left + plotW / 2}" y="${p2Top - 10}" text-anchor="middle" fill="#374151" font-size="13" font-weight="bold">Proxy covariate contributions (solar + QBO)</text>`);

// Attribution footnote
svg.push(`<text x="${margin.left}" y="${H - 6}" fill="#9ca3af" font-size="9">Data: Laine, Latva-Pukkila &amp; Kyrölä (2014), Atmos. Chem. Phys. 14, 9707–9725, doi:10.5194/acp-14-9707-2014. Instruments: SAGE II &amp; GOMOS. Data file via github.com/mjlaine/dlm.</text>`);

svg.push("</svg>");

const outPath = resolve(root, `assets/ozone-demo-${variant}.svg`);
writeSvg(svg, outPath);
