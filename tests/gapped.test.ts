/**
 * Gapped data (NaN observation) tests.
 *
 * Verifies that dlm-js correctly handles NaN observations by comparing
 * against Octave reference output generated by tests/octave/gappeddata_test.m.
 *
 * Gapped data strategy (matching MATLAB dlmsmo):
 *   - Forward pass: skip measurement update at NaN timesteps (K = 0, v = 0).
 *     State propagates as prior: x_{t|t} = x_{t|t-1}, C_{t|t} = G·C_{t|t-1}·G' + W.
 *   - Backward pass: skip Fisher-information contribution (N update masked).
 *     Ensures the smoother does not over-shrink uncertainty near gapped obs.
 *
 * Test data: Nile river flow (n=100) with a deterministic NaN pattern —
 * every 7th observation plus indices 30..39 → 23 NaN values, nobs=77.
 *
 * Keys compared against reference: x, xstd, yhat, ystd, nobs.
 * Arrays with Nan at missing positions (v, resid0, resid, resid2) are excluded
 * since JSON null ≠ NaN across the wire; deepAlmostEqual handles NaN vs NaN.
 */
import { describe, it, expect } from 'vitest';
import { dlmFit, toMatlab } from '../src/index';
import { filterKeys, deepAlmostEqual, normalizeNulls, normalizeMatlabOutput, withLeakCheck } from './utils';
import { getTestConfigs, applyConfig, getDlmDtype, type TestConfig } from './test-matrix';
import * as fs from 'fs';
import * as path from 'path';

// ── Reference file helpers ─────────────────────────────────────────────────

function loadPair(inFile: string, outFile: string): { inp: Record<string, unknown>; ref: Record<string, unknown> } {
  if (!fs.existsSync(inFile))  throw new Error(`Input file not found: ${inFile} — run: pnpm run test:octave`);
  if (!fs.existsSync(outFile)) throw new Error(`Reference file not found: ${outFile} — run: pnpm run test:octave`);
  const inp = JSON.parse(fs.readFileSync(inFile,  'utf-8')) as Record<string, unknown>;
  const ref = normalizeNulls(
    JSON.parse(fs.readFileSync(outFile, 'utf-8'))
  ) as Record<string, unknown>;
  return { inp, ref };
}

// Keys that are always finite (no Nan at missing positions) and safe to compare
const COMPARE_KEYS = ['x', 'xstd', 'yhat', 'ystd', 'nobs'];

// ── Test runner ───────────────────────────────────────────────────────────

const runTest = async (
  config: TestConfig,
  y: number[],
  s: number,
  w: number | number[],
  options: Record<string, unknown>,
  ref: Record<string, unknown>,
  label: string,
  m: number,  // state dimension, for MATLAB output normalization
) => {
  applyConfig(config);

  const outDir = path.join(__dirname, 'out');
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  const wArr = typeof w === 'number' ? [w] : w;

  const result = await withLeakCheck(() =>
    dlmFit(
      Float64Array.from(y.map(v => (v === null ? NaN : v))),
      {
        obsStd: s,
        processStd: wArr as number[],
        dtype: getDlmDtype(config),
        ...(options as any),
      },
    )
  );

  const matlab = toMatlab(result);

  // ── Check nobs matches reference ─────────────────────────────────────────
  const refNobs = ref['nobs'] as number;
  expect(matlab.nobs).toBe(refNobs);

  // Normalize Octave reference for structural differences (e.g. m=1 collapsing)
  const normalizedRef = normalizeMatlabOutput(ref as Record<string, unknown>, m);

  // ── Numeric comparison of state estimates and predictions ────────────────
  const outputFileName = path.join(outDir,
    `gapped-${label}-${config.label.replace('/', '-')}.json`);
  fs.writeFileSync(outputFileName, JSON.stringify(matlab, (_key, value) =>
    ArrayBuffer.isView(value) ? Array.from(value as Float64Array) : value
  , 2));

  const filteredResult    = filterKeys(matlab, COMPARE_KEYS) as Record<string, unknown>;
  const filteredReference = filterKeys(normalizedRef, COMPARE_KEYS) as Record<string, unknown>;

  const cmp = deepAlmostEqual(
    filteredResult,
    filteredReference,
    config.relativeTolerance,
    '',
    config.absoluteTolerance,
  );
  if (!cmp.equal) {
    throw new Error(
      `[${config.label}] ${label}: Output does not match reference.\n` +
      `First mismatch at: ${cmp.path}\n` +
      `Result value:    ${JSON.stringify(cmp.a)}\n` +
      `Reference value: ${JSON.stringify(cmp.b)}`
    );
  }
};

// ── Load test data ─────────────────────────────────────────────────────────

const inFileA   = path.join(__dirname, 'gapped-in.json');
const refFileA  = path.join(__dirname, 'gapped-out-m.json');
const inFileB   = path.join(__dirname, 'gapped-order0-in.json');
const refFileB  = path.join(__dirname, 'gapped-order0-out-m.json');

if (!fs.existsSync(inFileA) || !fs.existsSync(refFileA) ||
    !fs.existsSync(inFileB) || !fs.existsSync(refFileB)) {
  throw new Error(
    'Gapped data reference files not found — run: pnpm run test:octave:gapped'
  );
}

const { inp: inpA, ref: refA } = loadPair(inFileA, refFileA);
const { inp: inpB, ref: refB } = loadPair(inFileB, refFileB);

// y_gapped contains null (from JSON) where observations are NaN
const y_gapped = inpA['y'] as (number | null)[];
const s          = inpA['s'] as number;
const w          = inpA['w'] as number[];
const w_level    = (inpB['w'] instanceof Array ? inpB['w'][0] : inpB['w']) as number;

// ── Test suites ────────────────────────────────────────────────────────────

describe('gapped data (NaN observations) — order=1 (m=2)', async () => {
  const configs = await getTestConfigs();

  for (const config of configs) {
    it(`should match Octave reference (${config.label})`, async () => {
      await runTest(config, y_gapped as number[], s, w, { order: 1 }, refA, 'order1', 2);
    });

    it(`should match Octave reference — 2nd run (${config.label})`, async () => {
      await runTest(config, y_gapped as number[], s, w, { order: 1 }, refA, 'order1', 2);
    });
  }
});

describe('gapped data (NaN observations) — order=0 (m=1)', async () => {
  const configs = await getTestConfigs();

  for (const config of configs) {
    it(`should match Octave reference (${config.label})`, async () => {
      await runTest(config, y_gapped as number[], s, w_level, { order: 0 }, refB, 'order0', 1);
    });

    it(`should match Octave reference — 2nd run (${config.label})`, async () => {
      await runTest(config, y_gapped as number[], s, w_level, { order: 0 }, refB, 'order0', 1);
    });
  }
});
