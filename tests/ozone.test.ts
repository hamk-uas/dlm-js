/**
 * Ozone demo: real satellite data vs MATLAB/Octave DLM reference.
 *
 * Reference generated by tests/octave/ozonedemo.m — runs dlmfit() with:
 *   options = struct('trig',2,'order',1), 3 proxy covariates (solar, qbo1, qbo2),
 *   per-observation sigma array (SAGE II + GOMOS uncertainty),
 *   no MCMC (pure Kalman filter + RTS smoother).
 *
 * Data: Laine, Latva-Pukkila & Kyrölä (2014), ACP 14(18),
 *       doi:10.5194/acp-14-9707-2014 — stratospheric ozone 1984–2011.
 *
 * State layout (m=9, order=1+trig=2+q=3):
 *   x[0]=level, x[1]=slope, x[2..5]=4 trig states, x[6]=β_solar, x[7]=β_qbo1, x[8]=β_qbo2
 */
import { checkLeaks } from '@hamk-uas/jax-js-nonconsuming';
import { describe, it } from 'vitest';
import { dlmFit } from '../src/index';
import { deepAlmostEqual } from './utils';
import { getTestConfigs, applyConfig, type TestConfig } from './test-matrix';
import * as fs from 'fs';
import * as path from 'path';

const inputFile  = path.join(__dirname, 'ozone-in.json');
const refFile    = path.join(__dirname, 'ozone-out-m.json');

if (!fs.existsSync(inputFile)) {
  throw new Error(`Input file not found: ${inputFile} — run: pnpm run test:octave`);
}
if (!fs.existsSync(refFile)) {
  throw new Error(`Reference file not found: ${refFile} — run: pnpm run test:octave`);
}

const inp = JSON.parse(fs.readFileSync(inputFile,  'utf-8'));
const ref = JSON.parse(fs.readFileSync(refFile,    'utf-8'));

// Convert MATLAB X [N,3] nested array → per-row array X[t] = [solar,qbo1,qbo2]
// jsondecode stores it as N×3 2-D array (array of 3-element arrays)
const X_rows: number[][] = (inp.X as number[][]).map(row => Array.from(row));

// Keys to compare: smoothed states + their std devs + predicted obs
const COMPARE_KEYS = ['x', 'xstd', 'yhat'];

const withLeakCheck = async <T>(fn: () => Promise<T>): Promise<T> => {
  const guard = checkLeaks.start();
  try {
    return await fn();
  } finally {
    checkLeaks.stop(guard);
  }
};

const runTest = async (config: TestConfig) => {
  applyConfig(config);

  const outDir = path.join(__dirname, 'out');
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  const result = await withLeakCheck(() =>
    dlmFit(
      inp.yy,                        // scaled observations (NaN-filled)
      inp.ss,                        // per-observation sigma array (scaled)
      inp.w,                         // [0, wtrend, wseas, wseas, wseas, wseas]
      config.dtype,
      { order: 1, trig: 2 },
      X_rows,                        // n×3 covariate rows [solar, qbo1, qbo2]
    )
  );

  const outFile = path.join(outDir, `ozone-out-${config.label.replace('/', '-')}.json`);
  fs.writeFileSync(outFile, JSON.stringify(result, (_k, v) =>
    ArrayBuffer.isView(v) ? Array.from(v as Float64Array) : v
  , 2));

  // Compare only selected keys to keep the diff tractable
  const pick = (obj: Record<string, unknown>, keys: string[]) =>
    Object.fromEntries(keys.map(k => [k, obj[k]]));

  const resultFiltered   = pick(result as unknown as Record<string, unknown>, COMPARE_KEYS);
  const referenceFiltered = pick(ref,   COMPARE_KEYS);

  const cmp = deepAlmostEqual(
    resultFiltered,
    referenceFiltered,
    config.relativeTolerance,
    '',
    config.absoluteTolerance,
  );

  if (!cmp.equal) {
    throw new Error(
      `[${config.label}] Ozone output does not match Octave reference.\n` +
      `First mismatch at: ${cmp.path}\n` +
      `Result value:    ${JSON.stringify(cmp.a)}\n` +
      `Reference value: ${JSON.stringify(cmp.b)}`
    );
  }
};

describe('ozone demo vs Octave reference', async () => {
  const configs = await getTestConfigs();

  for (const config of configs) {
    // Float32 with m=9 > 2 states is numerically unstable — skip (same policy as gensys/synthetic)
    if (config.label.includes('f32')) continue;

    it(`should match reference (${config.label})`, async () => {
      await runTest(config);
    });
  }
});
